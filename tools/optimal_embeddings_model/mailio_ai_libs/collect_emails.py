# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_collect_emails.ipynb.

# %% auto 0
__all__ = ['project_root', 'split_into_sentences', 'cleanup_sentence', 'message_to_sentences', 'create_query',
           'get_decoded_email_data', 'extract_html', 'extract_text', 'extract_subject', 'extract_sender',
           'extract_message_id', 'extract_folder', 'extract_created', 'extract_message_type', 'list_emails',
           'save_emails_to_jsonl']

# %% ../nbs/01_collect_emails.ipynb 1
import os
from ibmcloudant.cloudant_v1 import CloudantV1
from ibm_cloud_sdk_core.authenticators import BasicAuthenticator
from dataclasses import asdict
import sys
import base64
import json
import nltk
from nltk.tokenize import sent_tokenize
import unicodedata
from bs4 import BeautifulSoup
import re
from typing import List, Optional
import email.utils as email_parser_utils

project_root = os.path.abspath(os.path.join(os.getcwd(), '../../..'))
sys.path.append(project_root)

from tools.optimal_embeddings_model.data_types.email import Email, MessageType, json_encoder

nltk.download('punkt')
nltk.download('punkt_tab')


# %% ../nbs/01_collect_emails.ipynb 4
def split_into_sentences(text):
    """
    Takes a string of text and returns a list of sentences.
    """
    sentences = sent_tokenize(text)
    return sentences

def cleanup_sentence(sentence:str) -> str:
    """
    Cleans up a sentence by removing special characters and extra spaces.
    """
    if sentence is not None:
        sentence = re.sub(r'\s+', ' ', sentence)
        sentence = sentence.encode('ascii', 'ignore').decode()
        return sentence.strip()
    return sentence

def message_to_sentences(message_type: MessageType, message:str) -> Email:
    sentences = []
    if message is None:
        return sentences
    if message_type == MessageType.HTML:
        soup = BeautifulSoup(message, 'html.parser')
        
        # remove all links
        for a_tag in soup.find_all("a"):
            a_tag.decompose()  # Removes the <a> tag 
        
        # remove all images
        for img_tag in soup.find_all("img"):
            img_tag.decompose()  # Removes the <img> tag
        
        html = soup.get_text()
        text = unicodedata.normalize('NFD', html)

        sentences = split_into_sentences(text)
        sentences = [cleanup_sentence(sentence) for sentence in sentences]
    else:
        text = unicodedata.normalize('NFD', message)
        sentences = split_into_sentences(text)
        sentences = [cleanup_sentence(sentence) for sentence in sentences]
        
    return sentences

# %% ../nbs/01_collect_emails.ipynb 5
def create_query(folder:str):
    query = {
    "selector": {
        "folder": {
            "$eq": f"{folder}"
        },
        "created": {
            "$gt": 0
        }
    },
    "sort": [
        {
            "folder": "desc"
        },
        {
            "created": "desc"
        }
    ],
   'use_index': 'client-folder-created-desc-index'
    }
    return query

def get_decoded_email_data(email, key) -> Optional[str]:
    """
    Helper function to decode email data and extract a specific key.
    """
    didComm = email.get("didCommMessage")
    if didComm:
        plainBody = base64.b64decode(didComm.get("plainBodyBase64", "")).decode("utf-8")
        email_data = json.loads(plainBody)
        return email_data.get(key, None)
    return None

def extract_html(email):
    """
    Extract the HTML body from the email.
    Returns None if the email does not contain HTML.
    """
    return get_decoded_email_data(email, "bodyHtml")

def extract_text(email):
    """
    Extract the text body from the email.
    Returns None if the email does not contain text.
    """
    return get_decoded_email_data(email, "bodyText")

def extract_subject(email):
    """
    Extract the subject from the email.
    Returns None if the email does not contain a subject.
    """
    return get_decoded_email_data(email, "subject")

def extract_sender(email):
    """
    Extract the sender from the email.
    Returns None if the email does not contain a sender.
    """
    from_sender = get_decoded_email_data(email, "from")
    if from_sender is None:
        raise ValueError("No sender email found in the email")
    
    address = from_sender.get("Address") if from_sender and "Address" in from_sender else None
    if address is None:             
        # try to parse the email address
        name, address = email_parser_utils.parseaddr(from_sender)
        return name, address
    
    name = from_sender.get("Name") if from_sender and "Name" in from_sender else None
    return name, address

def extract_message_id(email):
    """
    Extract the message ID from the email.
    Returns None if the email does not contain a message ID.
    """
    return email.get("_id", None)

def extract_folder(email):
    """
    Extract the folder from the email
    Returns None if the email does not contain a folder
    """
    folder = email.get("folder", None)
    return folder

def extract_created(email):
    """
    Extract the created timestamp from the email
    Returns None if the email does not contain a created timestamp
    """
    created = email.get("created", None)
    return created

def extract_message_type(email):
    """
    Extract the message type from the email
    Returns None if the email does not contain a message type
    """
    didComm = email.get("didCommMessage")
    if didComm:
        return didComm.get("type", None)
    return None

def list_emails(client, db_name:str, folder:str, bookmark="", limit=10):
    """
    List emails from the database 
    """
    emails = []
    query = create_query(folder)
    last_emails = client.post_find(db=db_name, selector=query["selector"], sort=query["sort"], use_index=query["use_index"], bookmark=bookmark,limit=limit)
    for i, doc in enumerate(last_emails.result["docs"]):
        # if i == 0:
        #     dt = datetime.fromtimestamp(doc["created"] / 1000)
        #     print(f"First email: {dt}") 
        msg_type = extract_message_type(doc)
        # skip encrypted emails, list only SMTP emails
        if msg_type is None or msg_type != "application/mailio-smtp+json":
            continue
        message = extract_html(doc)
        message_type = MessageType.HTML
        if message is None:
            message = extract_text(doc)
            message_type = MessageType.TEXT
        
        subject = extract_subject(doc)
        s_name, s_email = extract_sender(doc)
        folder = extract_folder(doc)
        message_id = extract_message_id(doc)
        if isinstance(subject, list):
            subject = ".".join(filter(lambda s: s.strip(), subject))
        if isinstance(message_id, list):
            print("WTF?", message_id)
            raise ValueError("Message ID is a list")
        created = extract_created(doc)
        sentences = message_to_sentences(message_type, message)
        email = Email(message_type=message_type, sentences=sentences, subject=subject, sender_name=s_name, sender_email=s_email, message_id=message_id, folder=folder, created=created)
        

        emails.append(email)
        
    yield emails, last_emails.result["bookmark"]

# %% ../nbs/01_collect_emails.ipynb 6
# save the emails to newline delimited JSON file
def save_emails_to_jsonl(file_path, folder, limit):
    processed = 0
    with open(file_path, "w") as f:
        bm = ""
        while True:
            for emails, bookmark in list_emails(client, folder, bm, limit=limit):
                
                if len(emails) == 0:
                    bm = None
                    break

                for e in emails:
                    email_dict = asdict(e)
                    email_json = json.dumps(email_dict, default=json_encoder)
                    f.write(email_json)
                    f.write("\n")
                    processed += 1
            
                bm = bookmark
                
            if not bm:
                break

    print(f"Processed {processed} emails for folder {folder}")
